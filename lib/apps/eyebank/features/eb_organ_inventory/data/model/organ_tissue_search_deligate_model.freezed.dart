// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'organ_tissue_search_deligate_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

OrganTissueSearchDeligateModel _$OrganTissueSearchDeligateModelFromJson(
    Map<String, dynamic> json) {
  return _OrganTissueSearchDeligateModel.fromJson(json);
}

/// @nodoc
mixin _$OrganTissueSearchDeligateModel {
  @JsonKey(name: "content")
  List<Content>? get content => throw _privateConstructorUsedError;
  @JsonKey(name: "totalElements")
  int? get totalElements => throw _privateConstructorUsedError;
  @JsonKey(name: "totalPages")
  int? get totalPages => throw _privateConstructorUsedError;
  @JsonKey(name: "size")
  int? get size => throw _privateConstructorUsedError;
  @JsonKey(name: "number")
  int? get number => throw _privateConstructorUsedError;
  @JsonKey(name: "numberOfElements")
  int? get numberOfElements => throw _privateConstructorUsedError;
  @JsonKey(name: "empty")
  bool? get empty => throw _privateConstructorUsedError;
  @JsonKey(name: "first")
  bool? get first => throw _privateConstructorUsedError;
  @JsonKey(name: "last")
  bool? get last => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OrganTissueSearchDeligateModelCopyWith<OrganTissueSearchDeligateModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrganTissueSearchDeligateModelCopyWith<$Res> {
  factory $OrganTissueSearchDeligateModelCopyWith(
          OrganTissueSearchDeligateModel value,
          $Res Function(OrganTissueSearchDeligateModel) then) =
      _$OrganTissueSearchDeligateModelCopyWithImpl<$Res,
          OrganTissueSearchDeligateModel>;
  @useResult
  $Res call(
      {@JsonKey(name: "content") List<Content>? content,
      @JsonKey(name: "totalElements") int? totalElements,
      @JsonKey(name: "totalPages") int? totalPages,
      @JsonKey(name: "size") int? size,
      @JsonKey(name: "number") int? number,
      @JsonKey(name: "numberOfElements") int? numberOfElements,
      @JsonKey(name: "empty") bool? empty,
      @JsonKey(name: "first") bool? first,
      @JsonKey(name: "last") bool? last});
}

/// @nodoc
class _$OrganTissueSearchDeligateModelCopyWithImpl<$Res,
        $Val extends OrganTissueSearchDeligateModel>
    implements $OrganTissueSearchDeligateModelCopyWith<$Res> {
  _$OrganTissueSearchDeligateModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? totalElements = freezed,
    Object? totalPages = freezed,
    Object? size = freezed,
    Object? number = freezed,
    Object? numberOfElements = freezed,
    Object? empty = freezed,
    Object? first = freezed,
    Object? last = freezed,
  }) {
    return _then(_value.copyWith(
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as List<Content>?,
      totalElements: freezed == totalElements
          ? _value.totalElements
          : totalElements // ignore: cast_nullable_to_non_nullable
              as int?,
      totalPages: freezed == totalPages
          ? _value.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      numberOfElements: freezed == numberOfElements
          ? _value.numberOfElements
          : numberOfElements // ignore: cast_nullable_to_non_nullable
              as int?,
      empty: freezed == empty
          ? _value.empty
          : empty // ignore: cast_nullable_to_non_nullable
              as bool?,
      first: freezed == first
          ? _value.first
          : first // ignore: cast_nullable_to_non_nullable
              as bool?,
      last: freezed == last
          ? _value.last
          : last // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$OrganTissueSearchDeligateModelImplCopyWith<$Res>
    implements $OrganTissueSearchDeligateModelCopyWith<$Res> {
  factory _$$OrganTissueSearchDeligateModelImplCopyWith(
          _$OrganTissueSearchDeligateModelImpl value,
          $Res Function(_$OrganTissueSearchDeligateModelImpl) then) =
      __$$OrganTissueSearchDeligateModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "content") List<Content>? content,
      @JsonKey(name: "totalElements") int? totalElements,
      @JsonKey(name: "totalPages") int? totalPages,
      @JsonKey(name: "size") int? size,
      @JsonKey(name: "number") int? number,
      @JsonKey(name: "numberOfElements") int? numberOfElements,
      @JsonKey(name: "empty") bool? empty,
      @JsonKey(name: "first") bool? first,
      @JsonKey(name: "last") bool? last});
}

/// @nodoc
class __$$OrganTissueSearchDeligateModelImplCopyWithImpl<$Res>
    extends _$OrganTissueSearchDeligateModelCopyWithImpl<$Res,
        _$OrganTissueSearchDeligateModelImpl>
    implements _$$OrganTissueSearchDeligateModelImplCopyWith<$Res> {
  __$$OrganTissueSearchDeligateModelImplCopyWithImpl(
      _$OrganTissueSearchDeligateModelImpl _value,
      $Res Function(_$OrganTissueSearchDeligateModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = freezed,
    Object? totalElements = freezed,
    Object? totalPages = freezed,
    Object? size = freezed,
    Object? number = freezed,
    Object? numberOfElements = freezed,
    Object? empty = freezed,
    Object? first = freezed,
    Object? last = freezed,
  }) {
    return _then(_$OrganTissueSearchDeligateModelImpl(
      content: freezed == content
          ? _value._content
          : content // ignore: cast_nullable_to_non_nullable
              as List<Content>?,
      totalElements: freezed == totalElements
          ? _value.totalElements
          : totalElements // ignore: cast_nullable_to_non_nullable
              as int?,
      totalPages: freezed == totalPages
          ? _value.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int?,
      numberOfElements: freezed == numberOfElements
          ? _value.numberOfElements
          : numberOfElements // ignore: cast_nullable_to_non_nullable
              as int?,
      empty: freezed == empty
          ? _value.empty
          : empty // ignore: cast_nullable_to_non_nullable
              as bool?,
      first: freezed == first
          ? _value.first
          : first // ignore: cast_nullable_to_non_nullable
              as bool?,
      last: freezed == last
          ? _value.last
          : last // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$OrganTissueSearchDeligateModelImpl
    implements _OrganTissueSearchDeligateModel {
  const _$OrganTissueSearchDeligateModelImpl(
      {@JsonKey(name: "content") final List<Content>? content,
      @JsonKey(name: "totalElements") this.totalElements,
      @JsonKey(name: "totalPages") this.totalPages,
      @JsonKey(name: "size") this.size,
      @JsonKey(name: "number") this.number,
      @JsonKey(name: "numberOfElements") this.numberOfElements,
      @JsonKey(name: "empty") this.empty,
      @JsonKey(name: "first") this.first,
      @JsonKey(name: "last") this.last})
      : _content = content;

  factory _$OrganTissueSearchDeligateModelImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$OrganTissueSearchDeligateModelImplFromJson(json);

  final List<Content>? _content;
  @override
  @JsonKey(name: "content")
  List<Content>? get content {
    final value = _content;
    if (value == null) return null;
    if (_content is EqualUnmodifiableListView) return _content;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey(name: "totalElements")
  final int? totalElements;
  @override
  @JsonKey(name: "totalPages")
  final int? totalPages;
  @override
  @JsonKey(name: "size")
  final int? size;
  @override
  @JsonKey(name: "number")
  final int? number;
  @override
  @JsonKey(name: "numberOfElements")
  final int? numberOfElements;
  @override
  @JsonKey(name: "empty")
  final bool? empty;
  @override
  @JsonKey(name: "first")
  final bool? first;
  @override
  @JsonKey(name: "last")
  final bool? last;

  @override
  String toString() {
    return 'OrganTissueSearchDeligateModel(content: $content, totalElements: $totalElements, totalPages: $totalPages, size: $size, number: $number, numberOfElements: $numberOfElements, empty: $empty, first: $first, last: $last)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrganTissueSearchDeligateModelImpl &&
            const DeepCollectionEquality().equals(other._content, _content) &&
            (identical(other.totalElements, totalElements) ||
                other.totalElements == totalElements) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.numberOfElements, numberOfElements) ||
                other.numberOfElements == numberOfElements) &&
            (identical(other.empty, empty) || other.empty == empty) &&
            (identical(other.first, first) || other.first == first) &&
            (identical(other.last, last) || other.last == last));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_content),
      totalElements,
      totalPages,
      size,
      number,
      numberOfElements,
      empty,
      first,
      last);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OrganTissueSearchDeligateModelImplCopyWith<
          _$OrganTissueSearchDeligateModelImpl>
      get copyWith => __$$OrganTissueSearchDeligateModelImplCopyWithImpl<
          _$OrganTissueSearchDeligateModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OrganTissueSearchDeligateModelImplToJson(
      this,
    );
  }
}

abstract class _OrganTissueSearchDeligateModel
    implements OrganTissueSearchDeligateModel {
  const factory _OrganTissueSearchDeligateModel(
          {@JsonKey(name: "content") final List<Content>? content,
          @JsonKey(name: "totalElements") final int? totalElements,
          @JsonKey(name: "totalPages") final int? totalPages,
          @JsonKey(name: "size") final int? size,
          @JsonKey(name: "number") final int? number,
          @JsonKey(name: "numberOfElements") final int? numberOfElements,
          @JsonKey(name: "empty") final bool? empty,
          @JsonKey(name: "first") final bool? first,
          @JsonKey(name: "last") final bool? last}) =
      _$OrganTissueSearchDeligateModelImpl;

  factory _OrganTissueSearchDeligateModel.fromJson(Map<String, dynamic> json) =
      _$OrganTissueSearchDeligateModelImpl.fromJson;

  @override
  @JsonKey(name: "content")
  List<Content>? get content;
  @override
  @JsonKey(name: "totalElements")
  int? get totalElements;
  @override
  @JsonKey(name: "totalPages")
  int? get totalPages;
  @override
  @JsonKey(name: "size")
  int? get size;
  @override
  @JsonKey(name: "number")
  int? get number;
  @override
  @JsonKey(name: "numberOfElements")
  int? get numberOfElements;
  @override
  @JsonKey(name: "empty")
  bool? get empty;
  @override
  @JsonKey(name: "first")
  bool? get first;
  @override
  @JsonKey(name: "last")
  bool? get last;
  @override
  @JsonKey(ignore: true)
  _$$OrganTissueSearchDeligateModelImplCopyWith<
          _$OrganTissueSearchDeligateModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Content _$ContentFromJson(Map<String, dynamic> json) {
  return _Content.fromJson(json);
}

/// @nodoc
mixin _$Content {
  @JsonKey(name: "id")
  int? get id => throw _privateConstructorUsedError;
  @JsonKey(name: "tissueId")
  String? get tissueId => throw _privateConstructorUsedError;
  @JsonKey(name: "identifier")
  String? get identifier => throw _privateConstructorUsedError;
  @JsonKey(name: "productCategory")
  String? get productCategory => throw _privateConstructorUsedError;
  @JsonKey(name: "productCode")
  String? get productCode => throw _privateConstructorUsedError;
  @JsonKey(name: "productStatus")
  dynamic get productStatus => throw _privateConstructorUsedError;
  @JsonKey(name: "expiryDate")
  dynamic get expiryDate => throw _privateConstructorUsedError;
  @JsonKey(name: "lotNumber")
  dynamic get lotNumber => throw _privateConstructorUsedError;
  @JsonKey(name: "storageMedium")
  dynamic get storageMedium => throw _privateConstructorUsedError;
  @JsonKey(name: "properties")
  dynamic get properties => throw _privateConstructorUsedError;
  @JsonKey(name: "storageTemp")
  dynamic get storageTemp => throw _privateConstructorUsedError;
  @JsonKey(name: "document")
  dynamic get document => throw _privateConstructorUsedError;
  @JsonKey(name: "recoveryInformation")
  RecoveryInformation? get recoveryInformation =>
      throw _privateConstructorUsedError;
  @JsonKey(name: "encounterId")
  int? get encounterId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContentCopyWith<Content> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContentCopyWith<$Res> {
  factory $ContentCopyWith(Content value, $Res Function(Content) then) =
      _$ContentCopyWithImpl<$Res, Content>;
  @useResult
  $Res call(
      {@JsonKey(name: "id") int? id,
      @JsonKey(name: "tissueId") String? tissueId,
      @JsonKey(name: "identifier") String? identifier,
      @JsonKey(name: "productCategory") String? productCategory,
      @JsonKey(name: "productCode") String? productCode,
      @JsonKey(name: "productStatus") dynamic productStatus,
      @JsonKey(name: "expiryDate") dynamic expiryDate,
      @JsonKey(name: "lotNumber") dynamic lotNumber,
      @JsonKey(name: "storageMedium") dynamic storageMedium,
      @JsonKey(name: "properties") dynamic properties,
      @JsonKey(name: "storageTemp") dynamic storageTemp,
      @JsonKey(name: "document") dynamic document,
      @JsonKey(name: "recoveryInformation")
      RecoveryInformation? recoveryInformation,
      @JsonKey(name: "encounterId") int? encounterId});

  $RecoveryInformationCopyWith<$Res>? get recoveryInformation;
}

/// @nodoc
class _$ContentCopyWithImpl<$Res, $Val extends Content>
    implements $ContentCopyWith<$Res> {
  _$ContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? tissueId = freezed,
    Object? identifier = freezed,
    Object? productCategory = freezed,
    Object? productCode = freezed,
    Object? productStatus = freezed,
    Object? expiryDate = freezed,
    Object? lotNumber = freezed,
    Object? storageMedium = freezed,
    Object? properties = freezed,
    Object? storageTemp = freezed,
    Object? document = freezed,
    Object? recoveryInformation = freezed,
    Object? encounterId = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      tissueId: freezed == tissueId
          ? _value.tissueId
          : tissueId // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      productCategory: freezed == productCategory
          ? _value.productCategory
          : productCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      productCode: freezed == productCode
          ? _value.productCode
          : productCode // ignore: cast_nullable_to_non_nullable
              as String?,
      productStatus: freezed == productStatus
          ? _value.productStatus
          : productStatus // ignore: cast_nullable_to_non_nullable
              as dynamic,
      expiryDate: freezed == expiryDate
          ? _value.expiryDate
          : expiryDate // ignore: cast_nullable_to_non_nullable
              as dynamic,
      lotNumber: freezed == lotNumber
          ? _value.lotNumber
          : lotNumber // ignore: cast_nullable_to_non_nullable
              as dynamic,
      storageMedium: freezed == storageMedium
          ? _value.storageMedium
          : storageMedium // ignore: cast_nullable_to_non_nullable
              as dynamic,
      properties: freezed == properties
          ? _value.properties
          : properties // ignore: cast_nullable_to_non_nullable
              as dynamic,
      storageTemp: freezed == storageTemp
          ? _value.storageTemp
          : storageTemp // ignore: cast_nullable_to_non_nullable
              as dynamic,
      document: freezed == document
          ? _value.document
          : document // ignore: cast_nullable_to_non_nullable
              as dynamic,
      recoveryInformation: freezed == recoveryInformation
          ? _value.recoveryInformation
          : recoveryInformation // ignore: cast_nullable_to_non_nullable
              as RecoveryInformation?,
      encounterId: freezed == encounterId
          ? _value.encounterId
          : encounterId // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RecoveryInformationCopyWith<$Res>? get recoveryInformation {
    if (_value.recoveryInformation == null) {
      return null;
    }

    return $RecoveryInformationCopyWith<$Res>(_value.recoveryInformation!,
        (value) {
      return _then(_value.copyWith(recoveryInformation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContentImplCopyWith<$Res> implements $ContentCopyWith<$Res> {
  factory _$$ContentImplCopyWith(
          _$ContentImpl value, $Res Function(_$ContentImpl) then) =
      __$$ContentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "id") int? id,
      @JsonKey(name: "tissueId") String? tissueId,
      @JsonKey(name: "identifier") String? identifier,
      @JsonKey(name: "productCategory") String? productCategory,
      @JsonKey(name: "productCode") String? productCode,
      @JsonKey(name: "productStatus") dynamic productStatus,
      @JsonKey(name: "expiryDate") dynamic expiryDate,
      @JsonKey(name: "lotNumber") dynamic lotNumber,
      @JsonKey(name: "storageMedium") dynamic storageMedium,
      @JsonKey(name: "properties") dynamic properties,
      @JsonKey(name: "storageTemp") dynamic storageTemp,
      @JsonKey(name: "document") dynamic document,
      @JsonKey(name: "recoveryInformation")
      RecoveryInformation? recoveryInformation,
      @JsonKey(name: "encounterId") int? encounterId});

  @override
  $RecoveryInformationCopyWith<$Res>? get recoveryInformation;
}

/// @nodoc
class __$$ContentImplCopyWithImpl<$Res>
    extends _$ContentCopyWithImpl<$Res, _$ContentImpl>
    implements _$$ContentImplCopyWith<$Res> {
  __$$ContentImplCopyWithImpl(
      _$ContentImpl _value, $Res Function(_$ContentImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? tissueId = freezed,
    Object? identifier = freezed,
    Object? productCategory = freezed,
    Object? productCode = freezed,
    Object? productStatus = freezed,
    Object? expiryDate = freezed,
    Object? lotNumber = freezed,
    Object? storageMedium = freezed,
    Object? properties = freezed,
    Object? storageTemp = freezed,
    Object? document = freezed,
    Object? recoveryInformation = freezed,
    Object? encounterId = freezed,
  }) {
    return _then(_$ContentImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      tissueId: freezed == tissueId
          ? _value.tissueId
          : tissueId // ignore: cast_nullable_to_non_nullable
              as String?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as String?,
      productCategory: freezed == productCategory
          ? _value.productCategory
          : productCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      productCode: freezed == productCode
          ? _value.productCode
          : productCode // ignore: cast_nullable_to_non_nullable
              as String?,
      productStatus: freezed == productStatus
          ? _value.productStatus
          : productStatus // ignore: cast_nullable_to_non_nullable
              as dynamic,
      expiryDate: freezed == expiryDate
          ? _value.expiryDate
          : expiryDate // ignore: cast_nullable_to_non_nullable
              as dynamic,
      lotNumber: freezed == lotNumber
          ? _value.lotNumber
          : lotNumber // ignore: cast_nullable_to_non_nullable
              as dynamic,
      storageMedium: freezed == storageMedium
          ? _value.storageMedium
          : storageMedium // ignore: cast_nullable_to_non_nullable
              as dynamic,
      properties: freezed == properties
          ? _value.properties
          : properties // ignore: cast_nullable_to_non_nullable
              as dynamic,
      storageTemp: freezed == storageTemp
          ? _value.storageTemp
          : storageTemp // ignore: cast_nullable_to_non_nullable
              as dynamic,
      document: freezed == document
          ? _value.document
          : document // ignore: cast_nullable_to_non_nullable
              as dynamic,
      recoveryInformation: freezed == recoveryInformation
          ? _value.recoveryInformation
          : recoveryInformation // ignore: cast_nullable_to_non_nullable
              as RecoveryInformation?,
      encounterId: freezed == encounterId
          ? _value.encounterId
          : encounterId // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContentImpl implements _Content {
  const _$ContentImpl(
      {@JsonKey(name: "id") this.id,
      @JsonKey(name: "tissueId") this.tissueId,
      @JsonKey(name: "identifier") this.identifier,
      @JsonKey(name: "productCategory") this.productCategory,
      @JsonKey(name: "productCode") this.productCode,
      @JsonKey(name: "productStatus") this.productStatus,
      @JsonKey(name: "expiryDate") this.expiryDate,
      @JsonKey(name: "lotNumber") this.lotNumber,
      @JsonKey(name: "storageMedium") this.storageMedium,
      @JsonKey(name: "properties") this.properties,
      @JsonKey(name: "storageTemp") this.storageTemp,
      @JsonKey(name: "document") this.document,
      @JsonKey(name: "recoveryInformation") this.recoveryInformation,
      @JsonKey(name: "encounterId") this.encounterId});

  factory _$ContentImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContentImplFromJson(json);

  @override
  @JsonKey(name: "id")
  final int? id;
  @override
  @JsonKey(name: "tissueId")
  final String? tissueId;
  @override
  @JsonKey(name: "identifier")
  final String? identifier;
  @override
  @JsonKey(name: "productCategory")
  final String? productCategory;
  @override
  @JsonKey(name: "productCode")
  final String? productCode;
  @override
  @JsonKey(name: "productStatus")
  final dynamic productStatus;
  @override
  @JsonKey(name: "expiryDate")
  final dynamic expiryDate;
  @override
  @JsonKey(name: "lotNumber")
  final dynamic lotNumber;
  @override
  @JsonKey(name: "storageMedium")
  final dynamic storageMedium;
  @override
  @JsonKey(name: "properties")
  final dynamic properties;
  @override
  @JsonKey(name: "storageTemp")
  final dynamic storageTemp;
  @override
  @JsonKey(name: "document")
  final dynamic document;
  @override
  @JsonKey(name: "recoveryInformation")
  final RecoveryInformation? recoveryInformation;
  @override
  @JsonKey(name: "encounterId")
  final int? encounterId;

  @override
  String toString() {
    return 'Content(id: $id, tissueId: $tissueId, identifier: $identifier, productCategory: $productCategory, productCode: $productCode, productStatus: $productStatus, expiryDate: $expiryDate, lotNumber: $lotNumber, storageMedium: $storageMedium, properties: $properties, storageTemp: $storageTemp, document: $document, recoveryInformation: $recoveryInformation, encounterId: $encounterId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContentImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.tissueId, tissueId) ||
                other.tissueId == tissueId) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.productCategory, productCategory) ||
                other.productCategory == productCategory) &&
            (identical(other.productCode, productCode) ||
                other.productCode == productCode) &&
            const DeepCollectionEquality()
                .equals(other.productStatus, productStatus) &&
            const DeepCollectionEquality()
                .equals(other.expiryDate, expiryDate) &&
            const DeepCollectionEquality().equals(other.lotNumber, lotNumber) &&
            const DeepCollectionEquality()
                .equals(other.storageMedium, storageMedium) &&
            const DeepCollectionEquality()
                .equals(other.properties, properties) &&
            const DeepCollectionEquality()
                .equals(other.storageTemp, storageTemp) &&
            const DeepCollectionEquality().equals(other.document, document) &&
            (identical(other.recoveryInformation, recoveryInformation) ||
                other.recoveryInformation == recoveryInformation) &&
            (identical(other.encounterId, encounterId) ||
                other.encounterId == encounterId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      tissueId,
      identifier,
      productCategory,
      productCode,
      const DeepCollectionEquality().hash(productStatus),
      const DeepCollectionEquality().hash(expiryDate),
      const DeepCollectionEquality().hash(lotNumber),
      const DeepCollectionEquality().hash(storageMedium),
      const DeepCollectionEquality().hash(properties),
      const DeepCollectionEquality().hash(storageTemp),
      const DeepCollectionEquality().hash(document),
      recoveryInformation,
      encounterId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContentImplCopyWith<_$ContentImpl> get copyWith =>
      __$$ContentImplCopyWithImpl<_$ContentImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContentImplToJson(
      this,
    );
  }
}

abstract class _Content implements Content {
  const factory _Content(
      {@JsonKey(name: "id") final int? id,
      @JsonKey(name: "tissueId") final String? tissueId,
      @JsonKey(name: "identifier") final String? identifier,
      @JsonKey(name: "productCategory") final String? productCategory,
      @JsonKey(name: "productCode") final String? productCode,
      @JsonKey(name: "productStatus") final dynamic productStatus,
      @JsonKey(name: "expiryDate") final dynamic expiryDate,
      @JsonKey(name: "lotNumber") final dynamic lotNumber,
      @JsonKey(name: "storageMedium") final dynamic storageMedium,
      @JsonKey(name: "properties") final dynamic properties,
      @JsonKey(name: "storageTemp") final dynamic storageTemp,
      @JsonKey(name: "document") final dynamic document,
      @JsonKey(name: "recoveryInformation")
      final RecoveryInformation? recoveryInformation,
      @JsonKey(name: "encounterId") final int? encounterId}) = _$ContentImpl;

  factory _Content.fromJson(Map<String, dynamic> json) = _$ContentImpl.fromJson;

  @override
  @JsonKey(name: "id")
  int? get id;
  @override
  @JsonKey(name: "tissueId")
  String? get tissueId;
  @override
  @JsonKey(name: "identifier")
  String? get identifier;
  @override
  @JsonKey(name: "productCategory")
  String? get productCategory;
  @override
  @JsonKey(name: "productCode")
  String? get productCode;
  @override
  @JsonKey(name: "productStatus")
  dynamic get productStatus;
  @override
  @JsonKey(name: "expiryDate")
  dynamic get expiryDate;
  @override
  @JsonKey(name: "lotNumber")
  dynamic get lotNumber;
  @override
  @JsonKey(name: "storageMedium")
  dynamic get storageMedium;
  @override
  @JsonKey(name: "properties")
  dynamic get properties;
  @override
  @JsonKey(name: "storageTemp")
  dynamic get storageTemp;
  @override
  @JsonKey(name: "document")
  dynamic get document;
  @override
  @JsonKey(name: "recoveryInformation")
  RecoveryInformation? get recoveryInformation;
  @override
  @JsonKey(name: "encounterId")
  int? get encounterId;
  @override
  @JsonKey(ignore: true)
  _$$ContentImplCopyWith<_$ContentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RecoveryInformation _$RecoveryInformationFromJson(Map<String, dynamic> json) {
  return _RecoveryInformation.fromJson(json);
}

/// @nodoc
mixin _$RecoveryInformation {
  @JsonKey(name: "id")
  int? get id => throw _privateConstructorUsedError;
  @JsonKey(name: "extractionMethod")
  String? get extractionMethod => throw _privateConstructorUsedError;
  @JsonKey(name: "extractionDateTime")
  DateTime? get extractionDateTime => throw _privateConstructorUsedError;
  @JsonKey(name: "lotNumber")
  String? get lotNumber => throw _privateConstructorUsedError;
  @JsonKey(name: "storageMedium")
  String? get storageMedium => throw _privateConstructorUsedError;
  @JsonKey(name: "expirationDate")
  DateTime? get expirationDate => throw _privateConstructorUsedError;
  @JsonKey(name: "intent")
  String? get intent => throw _privateConstructorUsedError;
  @JsonKey(name: "performedBy")
  String? get performedBy => throw _privateConstructorUsedError;
  @JsonKey(name: "performerRole")
  dynamic get performerRole => throw _privateConstructorUsedError;
  @JsonKey(name: "assistedBy")
  String? get assistedBy => throw _privateConstructorUsedError;
  @JsonKey(name: "assistedRole")
  dynamic get assistedRole => throw _privateConstructorUsedError;
  @JsonKey(name: "properties")
  Properties? get properties => throw _privateConstructorUsedError;
  @JsonKey(name: "storageTemp")
  dynamic get storageTemp => throw _privateConstructorUsedError;
  @JsonKey(name: "documents")
  dynamic get documents => throw _privateConstructorUsedError;
  @JsonKey(name: "productCategory")
  String? get productCategory => throw _privateConstructorUsedError;
  @JsonKey(name: "productCode")
  String? get productCode => throw _privateConstructorUsedError;
  @JsonKey(name: "productIdentifier")
  String? get productIdentifier => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RecoveryInformationCopyWith<RecoveryInformation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecoveryInformationCopyWith<$Res> {
  factory $RecoveryInformationCopyWith(
          RecoveryInformation value, $Res Function(RecoveryInformation) then) =
      _$RecoveryInformationCopyWithImpl<$Res, RecoveryInformation>;
  @useResult
  $Res call(
      {@JsonKey(name: "id") int? id,
      @JsonKey(name: "extractionMethod") String? extractionMethod,
      @JsonKey(name: "extractionDateTime") DateTime? extractionDateTime,
      @JsonKey(name: "lotNumber") String? lotNumber,
      @JsonKey(name: "storageMedium") String? storageMedium,
      @JsonKey(name: "expirationDate") DateTime? expirationDate,
      @JsonKey(name: "intent") String? intent,
      @JsonKey(name: "performedBy") String? performedBy,
      @JsonKey(name: "performerRole") dynamic performerRole,
      @JsonKey(name: "assistedBy") String? assistedBy,
      @JsonKey(name: "assistedRole") dynamic assistedRole,
      @JsonKey(name: "properties") Properties? properties,
      @JsonKey(name: "storageTemp") dynamic storageTemp,
      @JsonKey(name: "documents") dynamic documents,
      @JsonKey(name: "productCategory") String? productCategory,
      @JsonKey(name: "productCode") String? productCode,
      @JsonKey(name: "productIdentifier") String? productIdentifier});

  $PropertiesCopyWith<$Res>? get properties;
}

/// @nodoc
class _$RecoveryInformationCopyWithImpl<$Res, $Val extends RecoveryInformation>
    implements $RecoveryInformationCopyWith<$Res> {
  _$RecoveryInformationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extractionMethod = freezed,
    Object? extractionDateTime = freezed,
    Object? lotNumber = freezed,
    Object? storageMedium = freezed,
    Object? expirationDate = freezed,
    Object? intent = freezed,
    Object? performedBy = freezed,
    Object? performerRole = freezed,
    Object? assistedBy = freezed,
    Object? assistedRole = freezed,
    Object? properties = freezed,
    Object? storageTemp = freezed,
    Object? documents = freezed,
    Object? productCategory = freezed,
    Object? productCode = freezed,
    Object? productIdentifier = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      extractionMethod: freezed == extractionMethod
          ? _value.extractionMethod
          : extractionMethod // ignore: cast_nullable_to_non_nullable
              as String?,
      extractionDateTime: freezed == extractionDateTime
          ? _value.extractionDateTime
          : extractionDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lotNumber: freezed == lotNumber
          ? _value.lotNumber
          : lotNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      storageMedium: freezed == storageMedium
          ? _value.storageMedium
          : storageMedium // ignore: cast_nullable_to_non_nullable
              as String?,
      expirationDate: freezed == expirationDate
          ? _value.expirationDate
          : expirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      intent: freezed == intent
          ? _value.intent
          : intent // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: freezed == performedBy
          ? _value.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      performerRole: freezed == performerRole
          ? _value.performerRole
          : performerRole // ignore: cast_nullable_to_non_nullable
              as dynamic,
      assistedBy: freezed == assistedBy
          ? _value.assistedBy
          : assistedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      assistedRole: freezed == assistedRole
          ? _value.assistedRole
          : assistedRole // ignore: cast_nullable_to_non_nullable
              as dynamic,
      properties: freezed == properties
          ? _value.properties
          : properties // ignore: cast_nullable_to_non_nullable
              as Properties?,
      storageTemp: freezed == storageTemp
          ? _value.storageTemp
          : storageTemp // ignore: cast_nullable_to_non_nullable
              as dynamic,
      documents: freezed == documents
          ? _value.documents
          : documents // ignore: cast_nullable_to_non_nullable
              as dynamic,
      productCategory: freezed == productCategory
          ? _value.productCategory
          : productCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      productCode: freezed == productCode
          ? _value.productCode
          : productCode // ignore: cast_nullable_to_non_nullable
              as String?,
      productIdentifier: freezed == productIdentifier
          ? _value.productIdentifier
          : productIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PropertiesCopyWith<$Res>? get properties {
    if (_value.properties == null) {
      return null;
    }

    return $PropertiesCopyWith<$Res>(_value.properties!, (value) {
      return _then(_value.copyWith(properties: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RecoveryInformationImplCopyWith<$Res>
    implements $RecoveryInformationCopyWith<$Res> {
  factory _$$RecoveryInformationImplCopyWith(_$RecoveryInformationImpl value,
          $Res Function(_$RecoveryInformationImpl) then) =
      __$$RecoveryInformationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "id") int? id,
      @JsonKey(name: "extractionMethod") String? extractionMethod,
      @JsonKey(name: "extractionDateTime") DateTime? extractionDateTime,
      @JsonKey(name: "lotNumber") String? lotNumber,
      @JsonKey(name: "storageMedium") String? storageMedium,
      @JsonKey(name: "expirationDate") DateTime? expirationDate,
      @JsonKey(name: "intent") String? intent,
      @JsonKey(name: "performedBy") String? performedBy,
      @JsonKey(name: "performerRole") dynamic performerRole,
      @JsonKey(name: "assistedBy") String? assistedBy,
      @JsonKey(name: "assistedRole") dynamic assistedRole,
      @JsonKey(name: "properties") Properties? properties,
      @JsonKey(name: "storageTemp") dynamic storageTemp,
      @JsonKey(name: "documents") dynamic documents,
      @JsonKey(name: "productCategory") String? productCategory,
      @JsonKey(name: "productCode") String? productCode,
      @JsonKey(name: "productIdentifier") String? productIdentifier});

  @override
  $PropertiesCopyWith<$Res>? get properties;
}

/// @nodoc
class __$$RecoveryInformationImplCopyWithImpl<$Res>
    extends _$RecoveryInformationCopyWithImpl<$Res, _$RecoveryInformationImpl>
    implements _$$RecoveryInformationImplCopyWith<$Res> {
  __$$RecoveryInformationImplCopyWithImpl(_$RecoveryInformationImpl _value,
      $Res Function(_$RecoveryInformationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extractionMethod = freezed,
    Object? extractionDateTime = freezed,
    Object? lotNumber = freezed,
    Object? storageMedium = freezed,
    Object? expirationDate = freezed,
    Object? intent = freezed,
    Object? performedBy = freezed,
    Object? performerRole = freezed,
    Object? assistedBy = freezed,
    Object? assistedRole = freezed,
    Object? properties = freezed,
    Object? storageTemp = freezed,
    Object? documents = freezed,
    Object? productCategory = freezed,
    Object? productCode = freezed,
    Object? productIdentifier = freezed,
  }) {
    return _then(_$RecoveryInformationImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int?,
      extractionMethod: freezed == extractionMethod
          ? _value.extractionMethod
          : extractionMethod // ignore: cast_nullable_to_non_nullable
              as String?,
      extractionDateTime: freezed == extractionDateTime
          ? _value.extractionDateTime
          : extractionDateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      lotNumber: freezed == lotNumber
          ? _value.lotNumber
          : lotNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      storageMedium: freezed == storageMedium
          ? _value.storageMedium
          : storageMedium // ignore: cast_nullable_to_non_nullable
              as String?,
      expirationDate: freezed == expirationDate
          ? _value.expirationDate
          : expirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      intent: freezed == intent
          ? _value.intent
          : intent // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: freezed == performedBy
          ? _value.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      performerRole: freezed == performerRole
          ? _value.performerRole
          : performerRole // ignore: cast_nullable_to_non_nullable
              as dynamic,
      assistedBy: freezed == assistedBy
          ? _value.assistedBy
          : assistedBy // ignore: cast_nullable_to_non_nullable
              as String?,
      assistedRole: freezed == assistedRole
          ? _value.assistedRole
          : assistedRole // ignore: cast_nullable_to_non_nullable
              as dynamic,
      properties: freezed == properties
          ? _value.properties
          : properties // ignore: cast_nullable_to_non_nullable
              as Properties?,
      storageTemp: freezed == storageTemp
          ? _value.storageTemp
          : storageTemp // ignore: cast_nullable_to_non_nullable
              as dynamic,
      documents: freezed == documents
          ? _value.documents
          : documents // ignore: cast_nullable_to_non_nullable
              as dynamic,
      productCategory: freezed == productCategory
          ? _value.productCategory
          : productCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      productCode: freezed == productCode
          ? _value.productCode
          : productCode // ignore: cast_nullable_to_non_nullable
              as String?,
      productIdentifier: freezed == productIdentifier
          ? _value.productIdentifier
          : productIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RecoveryInformationImpl implements _RecoveryInformation {
  const _$RecoveryInformationImpl(
      {@JsonKey(name: "id") this.id,
      @JsonKey(name: "extractionMethod") this.extractionMethod,
      @JsonKey(name: "extractionDateTime") this.extractionDateTime,
      @JsonKey(name: "lotNumber") this.lotNumber,
      @JsonKey(name: "storageMedium") this.storageMedium,
      @JsonKey(name: "expirationDate") this.expirationDate,
      @JsonKey(name: "intent") this.intent,
      @JsonKey(name: "performedBy") this.performedBy,
      @JsonKey(name: "performerRole") this.performerRole,
      @JsonKey(name: "assistedBy") this.assistedBy,
      @JsonKey(name: "assistedRole") this.assistedRole,
      @JsonKey(name: "properties") this.properties,
      @JsonKey(name: "storageTemp") this.storageTemp,
      @JsonKey(name: "documents") this.documents,
      @JsonKey(name: "productCategory") this.productCategory,
      @JsonKey(name: "productCode") this.productCode,
      @JsonKey(name: "productIdentifier") this.productIdentifier});

  factory _$RecoveryInformationImpl.fromJson(Map<String, dynamic> json) =>
      _$$RecoveryInformationImplFromJson(json);

  @override
  @JsonKey(name: "id")
  final int? id;
  @override
  @JsonKey(name: "extractionMethod")
  final String? extractionMethod;
  @override
  @JsonKey(name: "extractionDateTime")
  final DateTime? extractionDateTime;
  @override
  @JsonKey(name: "lotNumber")
  final String? lotNumber;
  @override
  @JsonKey(name: "storageMedium")
  final String? storageMedium;
  @override
  @JsonKey(name: "expirationDate")
  final DateTime? expirationDate;
  @override
  @JsonKey(name: "intent")
  final String? intent;
  @override
  @JsonKey(name: "performedBy")
  final String? performedBy;
  @override
  @JsonKey(name: "performerRole")
  final dynamic performerRole;
  @override
  @JsonKey(name: "assistedBy")
  final String? assistedBy;
  @override
  @JsonKey(name: "assistedRole")
  final dynamic assistedRole;
  @override
  @JsonKey(name: "properties")
  final Properties? properties;
  @override
  @JsonKey(name: "storageTemp")
  final dynamic storageTemp;
  @override
  @JsonKey(name: "documents")
  final dynamic documents;
  @override
  @JsonKey(name: "productCategory")
  final String? productCategory;
  @override
  @JsonKey(name: "productCode")
  final String? productCode;
  @override
  @JsonKey(name: "productIdentifier")
  final String? productIdentifier;

  @override
  String toString() {
    return 'RecoveryInformation(id: $id, extractionMethod: $extractionMethod, extractionDateTime: $extractionDateTime, lotNumber: $lotNumber, storageMedium: $storageMedium, expirationDate: $expirationDate, intent: $intent, performedBy: $performedBy, performerRole: $performerRole, assistedBy: $assistedBy, assistedRole: $assistedRole, properties: $properties, storageTemp: $storageTemp, documents: $documents, productCategory: $productCategory, productCode: $productCode, productIdentifier: $productIdentifier)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RecoveryInformationImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.extractionMethod, extractionMethod) ||
                other.extractionMethod == extractionMethod) &&
            (identical(other.extractionDateTime, extractionDateTime) ||
                other.extractionDateTime == extractionDateTime) &&
            (identical(other.lotNumber, lotNumber) ||
                other.lotNumber == lotNumber) &&
            (identical(other.storageMedium, storageMedium) ||
                other.storageMedium == storageMedium) &&
            (identical(other.expirationDate, expirationDate) ||
                other.expirationDate == expirationDate) &&
            (identical(other.intent, intent) || other.intent == intent) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            const DeepCollectionEquality()
                .equals(other.performerRole, performerRole) &&
            (identical(other.assistedBy, assistedBy) ||
                other.assistedBy == assistedBy) &&
            const DeepCollectionEquality()
                .equals(other.assistedRole, assistedRole) &&
            (identical(other.properties, properties) ||
                other.properties == properties) &&
            const DeepCollectionEquality()
                .equals(other.storageTemp, storageTemp) &&
            const DeepCollectionEquality().equals(other.documents, documents) &&
            (identical(other.productCategory, productCategory) ||
                other.productCategory == productCategory) &&
            (identical(other.productCode, productCode) ||
                other.productCode == productCode) &&
            (identical(other.productIdentifier, productIdentifier) ||
                other.productIdentifier == productIdentifier));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      extractionMethod,
      extractionDateTime,
      lotNumber,
      storageMedium,
      expirationDate,
      intent,
      performedBy,
      const DeepCollectionEquality().hash(performerRole),
      assistedBy,
      const DeepCollectionEquality().hash(assistedRole),
      properties,
      const DeepCollectionEquality().hash(storageTemp),
      const DeepCollectionEquality().hash(documents),
      productCategory,
      productCode,
      productIdentifier);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RecoveryInformationImplCopyWith<_$RecoveryInformationImpl> get copyWith =>
      __$$RecoveryInformationImplCopyWithImpl<_$RecoveryInformationImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RecoveryInformationImplToJson(
      this,
    );
  }
}

abstract class _RecoveryInformation implements RecoveryInformation {
  const factory _RecoveryInformation(
      {@JsonKey(name: "id") final int? id,
      @JsonKey(name: "extractionMethod") final String? extractionMethod,
      @JsonKey(name: "extractionDateTime") final DateTime? extractionDateTime,
      @JsonKey(name: "lotNumber") final String? lotNumber,
      @JsonKey(name: "storageMedium") final String? storageMedium,
      @JsonKey(name: "expirationDate") final DateTime? expirationDate,
      @JsonKey(name: "intent") final String? intent,
      @JsonKey(name: "performedBy") final String? performedBy,
      @JsonKey(name: "performerRole") final dynamic performerRole,
      @JsonKey(name: "assistedBy") final String? assistedBy,
      @JsonKey(name: "assistedRole") final dynamic assistedRole,
      @JsonKey(name: "properties") final Properties? properties,
      @JsonKey(name: "storageTemp") final dynamic storageTemp,
      @JsonKey(name: "documents") final dynamic documents,
      @JsonKey(name: "productCategory") final String? productCategory,
      @JsonKey(name: "productCode") final String? productCode,
      @JsonKey(name: "productIdentifier")
      final String? productIdentifier}) = _$RecoveryInformationImpl;

  factory _RecoveryInformation.fromJson(Map<String, dynamic> json) =
      _$RecoveryInformationImpl.fromJson;

  @override
  @JsonKey(name: "id")
  int? get id;
  @override
  @JsonKey(name: "extractionMethod")
  String? get extractionMethod;
  @override
  @JsonKey(name: "extractionDateTime")
  DateTime? get extractionDateTime;
  @override
  @JsonKey(name: "lotNumber")
  String? get lotNumber;
  @override
  @JsonKey(name: "storageMedium")
  String? get storageMedium;
  @override
  @JsonKey(name: "expirationDate")
  DateTime? get expirationDate;
  @override
  @JsonKey(name: "intent")
  String? get intent;
  @override
  @JsonKey(name: "performedBy")
  String? get performedBy;
  @override
  @JsonKey(name: "performerRole")
  dynamic get performerRole;
  @override
  @JsonKey(name: "assistedBy")
  String? get assistedBy;
  @override
  @JsonKey(name: "assistedRole")
  dynamic get assistedRole;
  @override
  @JsonKey(name: "properties")
  Properties? get properties;
  @override
  @JsonKey(name: "storageTemp")
  dynamic get storageTemp;
  @override
  @JsonKey(name: "documents")
  dynamic get documents;
  @override
  @JsonKey(name: "productCategory")
  String? get productCategory;
  @override
  @JsonKey(name: "productCode")
  String? get productCode;
  @override
  @JsonKey(name: "productIdentifier")
  String? get productIdentifier;
  @override
  @JsonKey(ignore: true)
  _$$RecoveryInformationImplCopyWith<_$RecoveryInformationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Properties _$PropertiesFromJson(Map<String, dynamic> json) {
  return _Properties.fromJson(json);
}

/// @nodoc
mixin _$Properties {
  @JsonKey(name: "comments")
  String? get comments => throw _privateConstructorUsedError;
  @JsonKey(name: "scleraRecovered")
  int? get scleraRecovered => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PropertiesCopyWith<Properties> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PropertiesCopyWith<$Res> {
  factory $PropertiesCopyWith(
          Properties value, $Res Function(Properties) then) =
      _$PropertiesCopyWithImpl<$Res, Properties>;
  @useResult
  $Res call(
      {@JsonKey(name: "comments") String? comments,
      @JsonKey(name: "scleraRecovered") int? scleraRecovered});
}

/// @nodoc
class _$PropertiesCopyWithImpl<$Res, $Val extends Properties>
    implements $PropertiesCopyWith<$Res> {
  _$PropertiesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? comments = freezed,
    Object? scleraRecovered = freezed,
  }) {
    return _then(_value.copyWith(
      comments: freezed == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as String?,
      scleraRecovered: freezed == scleraRecovered
          ? _value.scleraRecovered
          : scleraRecovered // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PropertiesImplCopyWith<$Res>
    implements $PropertiesCopyWith<$Res> {
  factory _$$PropertiesImplCopyWith(
          _$PropertiesImpl value, $Res Function(_$PropertiesImpl) then) =
      __$$PropertiesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "comments") String? comments,
      @JsonKey(name: "scleraRecovered") int? scleraRecovered});
}

/// @nodoc
class __$$PropertiesImplCopyWithImpl<$Res>
    extends _$PropertiesCopyWithImpl<$Res, _$PropertiesImpl>
    implements _$$PropertiesImplCopyWith<$Res> {
  __$$PropertiesImplCopyWithImpl(
      _$PropertiesImpl _value, $Res Function(_$PropertiesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? comments = freezed,
    Object? scleraRecovered = freezed,
  }) {
    return _then(_$PropertiesImpl(
      comments: freezed == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as String?,
      scleraRecovered: freezed == scleraRecovered
          ? _value.scleraRecovered
          : scleraRecovered // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PropertiesImpl implements _Properties {
  const _$PropertiesImpl(
      {@JsonKey(name: "comments") this.comments,
      @JsonKey(name: "scleraRecovered") this.scleraRecovered});

  factory _$PropertiesImpl.fromJson(Map<String, dynamic> json) =>
      _$$PropertiesImplFromJson(json);

  @override
  @JsonKey(name: "comments")
  final String? comments;
  @override
  @JsonKey(name: "scleraRecovered")
  final int? scleraRecovered;

  @override
  String toString() {
    return 'Properties(comments: $comments, scleraRecovered: $scleraRecovered)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PropertiesImpl &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.scleraRecovered, scleraRecovered) ||
                other.scleraRecovered == scleraRecovered));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, comments, scleraRecovered);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PropertiesImplCopyWith<_$PropertiesImpl> get copyWith =>
      __$$PropertiesImplCopyWithImpl<_$PropertiesImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PropertiesImplToJson(
      this,
    );
  }
}

abstract class _Properties implements Properties {
  const factory _Properties(
          {@JsonKey(name: "comments") final String? comments,
          @JsonKey(name: "scleraRecovered") final int? scleraRecovered}) =
      _$PropertiesImpl;

  factory _Properties.fromJson(Map<String, dynamic> json) =
      _$PropertiesImpl.fromJson;

  @override
  @JsonKey(name: "comments")
  String? get comments;
  @override
  @JsonKey(name: "scleraRecovered")
  int? get scleraRecovered;
  @override
  @JsonKey(ignore: true)
  _$$PropertiesImplCopyWith<_$PropertiesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
